{{ define "main" }}
<!-- Hero Section with Complex Animated Background -->
<div class="hero-container">
  <div class="animated-background">
    <!-- Pixel Art Background Layers -->
    <div class="pixel-art-layers">
      <div class="pixel-layer layer-1" data-speed="0.2"></div>
      <div class="pixel-layer layer-2" data-speed="0.5"></div>
      <div class="pixel-layer layer-3" data-speed="0.8"></div>
    </div>
    <canvas id="mesh-canvas"></canvas>
    <div class="gradient-overlay"></div>
  </div>
  
  <div class="hero-content">
    <h1 class="hero-title">Hi, I am {{ .Site.Params.author }}</h1>
    <p class="hero-subtitle">I'm a {{ .Site.Params.subtitle }}!</p>
    
    <div class="hero-buttons">
      <a href="{{ "/games/" | relURL }}" class="btn-pill">GAMES</a>
      <a href="{{ "/projects/" | relURL }}" class="btn-pill">PROJECTS</a>
      <a href="{{ "/blog/" | relURL }}" class="btn-pill">BLOG</a>
    </div>
  </div>
</div>

<script>
// Complex mesh animation inspired by Amy Elliott's site
const canvas = document.getElementById('mesh-canvas');
const ctx = canvas.getContext('2d');

let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

// Configuration
const config = {
  particleCount: 150,
  particleSize: 2,
  lineDistance: 120,
  particleSpeed: 0.3,
  mouseRadius: 150,
  colors: {
    particle: '#4a9eff',
    line: 'rgba(74, 158, 255, 0.15)',
    glow: 'rgba(74, 158, 255, 0.6)'
  }
};

// Particle class
class Particle {
  constructor() {
    this.x = Math.random() * width;
    this.y = Math.random() * height;
    this.vx = (Math.random() - 0.5) * config.particleSpeed;
    this.vy = (Math.random() - 0.5) * config.particleSpeed;
    this.radius = Math.random() * config.particleSize + 1;
  }
  
  update() {
    // Bounce off edges
    if (this.x < 0 || this.x > width) this.vx = -this.vx;
    if (this.y < 0 || this.y > height) this.vy = -this.vy;
    
    // Update position
    this.x += this.vx;
    this.y += this.vy;
  }
  
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = config.colors.particle;
    ctx.fill();
    
    // Add glow effect
    ctx.shadowBlur = 10;
    ctx.shadowColor = config.colors.glow;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// Create particles
const particles = [];
for (let i = 0; i < config.particleCount; i++) {
  particles.push(new Particle());
}

// Mouse position
let mouse = {
  x: width / 2,
  y: height / 2
};

// Track mouse movement
window.addEventListener('mousemove', (e) => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

// Resize handler
window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
});

// Animation loop
function animate() {
  // Clear canvas with slight fade effect
  ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
  ctx.fillRect(0, 0, width, height);
  
  // Update and draw particles
  particles.forEach(particle => {
    particle.update();
    particle.draw();
  });
  
  // Draw connections
  particles.forEach((p1, i) => {
    // Connect to nearby particles
    particles.slice(i + 1).forEach(p2 => {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < config.lineDistance) {
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = config.colors.line;
        ctx.lineWidth = (1 - distance / config.lineDistance) * 2;
        ctx.stroke();
      }
    });
    
    // React to mouse
    const mouseDistance = Math.sqrt(
      Math.pow(p1.x - mouse.x, 2) + 
      Math.pow(p1.y - mouse.y, 2)
    );
    
    if (mouseDistance < config.mouseRadius) {
      const angle = Math.atan2(p1.y - mouse.y, p1.x - mouse.x);
      const force = (config.mouseRadius - mouseDistance) / config.mouseRadius;
      p1.vx += Math.cos(angle) * force * 0.1;
      p1.vy += Math.sin(angle) * force * 0.1;
    }
  });
  
  requestAnimationFrame(animate);
}

// Start animation
animate();

// Smooth reveal animation
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(() => {
    document.querySelector('.hero-content').classList.add('visible');
  }, 300);
});

// Parallax effect for pixel art layers
const pixelLayers = document.querySelectorAll('.pixel-layer');

window.addEventListener('mousemove', (e) => {
  const mouseX = e.clientX / window.innerWidth - 0.5;
  const mouseY = e.clientY / window.innerHeight - 0.5;
  
  pixelLayers.forEach((layer, index) => {
    const speed = parseFloat(layer.dataset.speed);
    const x = mouseX * speed * 50;
    const y = mouseY * speed * 50;
    
    layer.style.transform = `translate(${x}px, ${y}px) scale(1.1)`;
  });
});

// Scroll parallax for pixel layers
window.addEventListener('scroll', () => {
  const scrolled = window.scrollY;
  
  pixelLayers.forEach((layer, index) => {
    const speed = parseFloat(layer.dataset.speed);
    const yPos = -(scrolled * speed);
    
    layer.style.transform = `translateY(${yPos}px) scale(1.1)`;
  });
});
</script>

<style>
/* Hero specific styles */
.animated-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
}

/* Pixel Art Layers */
.pixel-art-layers {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.pixel-layer {
  position: absolute;
  width: 110%;
  height: 110%;
  background-size: 500px 500px;
  background-repeat: repeat;
  opacity: 0.15;
  filter: brightness(0.8) contrast(1.2);
  transition: transform 0.1s ease-out;
}

/* Layer 1 - Furthest back, slowest movement */
.layer-1 {
  background-image: url('{{ "/images/pixel-bg-1.svg" | relURL }}');
  opacity: 0.1;
  animation: float-1 20s ease-in-out infinite;
}

/* Layer 2 - Middle layer */
.layer-2 {
  background-image: url('{{ "/images/pixel-bg-2.svg" | relURL }}');
  opacity: 0.15;
  animation: float-2 15s ease-in-out infinite;
}

/* Layer 3 - Closest, fastest movement */
.layer-3 {
  background-image: url('{{ "/images/pixel-bg-3.svg" | relURL }}');
  opacity: 0.2;
  animation: float-3 10s ease-in-out infinite;
}

/* Floating animations for pixel layers */
@keyframes float-1 {
  0%, 100% { transform: translate(0, 0) scale(1.1); }
  50% { transform: translate(-20px, -20px) scale(1.15); }
}

@keyframes float-2 {
  0%, 100% { transform: translate(0, 0) scale(1.05); }
  33% { transform: translate(15px, -10px) scale(1.08); }
  66% { transform: translate(-10px, 15px) scale(1.1); }
}

@keyframes float-3 {
  0%, 100% { transform: translate(0, 0) scale(1); }
  25% { transform: translate(10px, -5px) scale(1.02); }
  50% { transform: translate(-5px, 10px) scale(1.05); }
  75% { transform: translate(5px, 5px) scale(1.02); }
}

#mesh-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.8;
}

.gradient-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.5) 100%);
  pointer-events: none;
}

.hero-content {
  opacity: 0;
  transform: translateY(30px);
  transition: all 1s cubic-bezier(0.4, 0, 0.2, 1);
}

.hero-content.visible {
  opacity: 1;
  transform: translateY(0);
}

.hero-subtitle {
  font-size: clamp(1.25rem, 2.5vw, 1.75rem);
  font-weight: 400;
  color: var(--text-secondary);
  margin-bottom: var(--space-xl);
}

/* Override button styles for homepage */
.hero-buttons .btn-pill {
  min-width: 140px;
}
</style>
{{ end }}